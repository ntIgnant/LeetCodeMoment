# Implement an Interative deepening search algorithm (IDS) to solve the problem of the Preworkshop
# Sort an array (potentially of any size) such as [1, 3, 2] in assending or dessending order by using IDS
# Don't create the phisical graph, but build it on the fly (logically)

# globals
SOURCE_NODE = [1, 3, 2]
GOAL_NODES = [] # possible goal node states

ascending = sorted(SOURCE_NODE)
descending = sorted(SOURCE_NODE, reverse=True)

GOAL_NODES.append(ascending)
GOAL_NODES.append(descending)

# utility Functions
def get_last_node(a_path): return a_path[-1] # this should return the last list of the list of lists

def get_successors(a_node):
    # in this case, the grpah will be ignored because the successors will be generated by logic, not physical graph

    successors = []
    for i in range(len(a_node) - 1):
        tmp_node = a_node.copy()
        # create the successor node by swapping the adjacent vales of the list
        tmp_node[i], tmp_node[i+1] = tmp_node[i+1], tmp_node[i]

        successors.append(tmp_node)
    
    return successors # this will return a list of lists, which will be the succerors based on the passed node

# dls
def dls(source_node, goal_nodes, limit):
    paths = [[source_node]] # create thr frontier for the paths to explore

    while paths != []:
        current_path, paths = paths[0], paths[1:]

        # check if the last node of the curren path has reached the destination
        path_last_node = get_last_node(current_path)

        if path_last_node in goal_nodes:
            return current_path
        
        # else, keep discovering paths, so verify the depth and continue
        curr_depth = len(current_path) - 1
        if curr_depth >= limit:
            continue

        # get the succersors of the last_current_node to create a new path and append to de frontier
        last_node_succ = get_successors(path_last_node)

        for nd in last_node_succ:
            if nd in current_path:
                continue
            new_path = current_path + [nd]
            paths = [new_path] + paths # append the new path to the frontier at index 0 | STACK BEHAVIOR

    return None # return none if there was no found path


# ids (progrgessive depth for dls)
def ids(source_node, goal_node, depth_limit):
    for lim in range(depth_limit + 1):
        result = dls(source_node, goal_node, lim)

        # case where a path is found | return the result of the DLS plus the depth at where it was found
        if result != None:
            return result, lim

    return None, None


test1 = ids(SOURCE_NODE, GOAL_NODES, 3)
print(test1)